
//Includes the iostream library file to include standard input and ouput for cin and cout
#include <iostream>
//Includes the C++ fstream libary for file input and output, open and close functionality
#include <fstream>
//Includes the C++ string library for string manipulation and implmentation
#include <string>
//Includes the C++ sstream library for file string parsing functionality
#include <sstream>
//Includes the C++ vector library for array manipulation and implementation
#include <vector>
#include <type_traits>
//Using standard namespace to avoid using std:: prefix
using namespace std;
// Template function to convert a string to a specified type (T)


template <typename T>
T stringToType(const string& str) {
    stringstream ss(str);
    T result;
    ss >> result; // Convert the string to the specified type
    return result;
}

template <typename T> class Matrix{
    private:
        int number_of_rows;
        int number_of_columns;
        vector<vector<T>> grid;
    public:
		Matrix(int rows, int columns);
		
		int get_number_of_rows();
		int get_number_of_columns();
		T get_cell_value(int row, int column);


		void store_cell_value(int row, int column, T value);
		
		void print_grid();
		Matrix<T> add_matrices(Matrix<T>& other);
		Matrix<T> multiply_matrices(Matrix<T>& other);
		void sum_diagonal();
		
		virtual Matrix<T> swap_rows(int row1, int row2);
		virtual Matrix<T> swap_columns(int column1, int column2);
		virtual Matrix<T> update_matrix(Matrix<T>& matrix,int row, int column, T value);

		Matrix<T> operator+(Matrix<T>&other);
		Matrix<T> operator*(Matrix<T>&other);
		
};



template <typename T> Matrix<T>::Matrix(int rows, int columns){
    number_of_rows = rows;
    number_of_columns = columns;
    grid.resize(rows, vector<T>(columns));
}

template <typename T> int Matrix<T>::get_number_of_rows(){
    return number_of_rows;
}

template <typename T> int Matrix<T>::get_number_of_columns(){
    return number_of_columns;
}

template <typename T> T Matrix<T>::get_cell_value(int row, int column){
    return grid[row][column];
}

template <typename T> void Matrix<T>::store_cell_value(int row, int column, T value){
    grid[row][column] = value;
}

template <typename T> void Matrix<T>::print_grid(){
    cout<< "Column ";
    //For in loop to iterate through eaach column and print a number to indicate position of cell
    for(int column = 1; column < number_of_columns+1; column++){
        ////Prints to terminal ouput a | to indicate a barrier spacing
        cout<< column << "|";
    }
    //Prints newline spacing
    cout<<"\n";
    //For in loop to iterate throguh each row
    for(int row= 0; row<number_of_rows; row++) {
        //Pritns to terminal ouput the Row and number wiht a | to indicate barreier spacing and cell location
        cout<< "Row "<<row + 1 << "| ";
        //For in loop to iterate through each columns
        for(int column = 0; column < number_of_columns; column++) {
            //Prints to terminal ouput the value at grid of row by column location witha  space
            cout<<grid[row][column]<< " ";
        }
        //Prints newline spacing
        cout<<"\n";
    }
}

template<typename T>
Matrix<T> Matrix<T>::operator+(Matrix<T>& other){
    Matrix<T> result(this->get_number_of_rows(),this->get_number_of_columns());
    
    for(int row = 0; row< this->get_number_of_rows();row++){
        for(int column = 0; column < this->get_number_of_columns();column++){
            T value = this->get_cell_value(row,column) + other.get_cell_value(row,column);
            result.store_cell_value(row,column,value);
        }
    }
    return result;
}

template<typename T>
Matrix<T> Matrix<T>::add_matrices(Matrix<T>& other){
    return *this + other;
    
}

template<typename T>
Matrix<T> Matrix<T>::operator*(Matrix<T>& other){
    Matrix<T> result(this->get_number_of_rows(),this->get_number_of_columns());
    
    for(int row = 0; row< this->get_number_of_rows();row++){
        for(int column = 0; column < this->get_number_of_columns();column++){
            T value = 0;
            for(int column_2 = 0;column_2 <this->get_number_of_columns();column_2++){
                value += this->get_cell_value(row,column_2) * other.get_cell_value(column_2,column);
                
            }
            result.store_cell_value(row,column,value);
        }
    }
    return result;
}
template <typename T>
Matrix<T> Matrix<T>::multiply_matrices(Matrix<T>& other){
    return *this * other;
    
}

template <typename T> void sum_diagonal(Matrix<T> matrix){
	//Declare and initializes column number to 0
	int column_number = 0;
	//Declares and initializes matrix 1 result main sum to 0
	T matrix_result_main_sum = 0;
	//Declares and initializes matrix 1 result secondary sum to 0
	T matrix_result_secondary_sum = 0;

	//For in loop to iterate through each row n matrix 1 number of rows
	for(int row = 0; row < matrix.get_number_of_rows(); row++) {
		//Matrix 1 result main sum is incremeneted by the value at matrix 1 gird at location row  by column number
		matrix_result_main_sum+=matrix.get_cell_value(row,column_number);
		//Column number is incremented
		column_number++;
	}

	//Column number is set to matrix 1 number of columns minus by 1
	column_number = matrix.get_number_of_columns()-1;
	//For in loop to iterate through each row n matrix 1 number of rows
	for(int row = 0; row < matrix.get_number_of_rows(); row++) {
		//Matrix 1 result main sum is incremeneted by the value at matrix 1 gird at location row  by column number
		matrix_result_secondary_sum+= matrix.get_cell_value(row,column_number);
		//Column number is decremented
		column_number--;
	}
	//Prints ouput to terminal the Matrix main diagonal sum 
	cout<<"Matrix Main Diagonal Sum " << matrix_result_main_sum << "\n";
	//Prints ouput to terminal the Matrix secondary diagonal sum 
	cout<<"Matrix Secondary Diagonal Sum"<< matrix_result_secondary_sum << "\n";
}

template <typename T>pair<Matrix<T>,Matrix<T>>create_matrices(string& matrix_text_file){
    cout << "In and our with type: " << typeid(T).name() << "\n";
    //Declares string line to hol line of file
	string line;
	//Declares and initializes integer line number to 1 to keep track of the number of line there are
	int line_number = 1;
	//Declares and initializes integer current row to -1 to keep track of the placment of rows to matrices
	int current_row=-1;
	//Declares and initializes integer current matrix 2 row to 0, to keep track of the placmeent of matrix 2 rows
	int current_matrix_2_row = 0;
	//Declares integer size of matrix to hold matrix size
	int size_of_matrix;
	int type_flag;
	//Matrix object matrix 1 is declared and initialized with with a 0,0 pair passed in to indicate the vector grid is 0,0 in size
	Matrix<T> matrix1(0,0);
	//Matrix object matrix 2 is declared and initialized with with a 0,0 pair passed in to indicate the vector grid is 0,0 in size
	Matrix<T> matrix2(0,0);

	//Opens the matrix text file in the matrix file ifstream object for reading and extracting information
	ifstream matrix_file(matrix_text_file);
	//The matrix file is opened
	if (matrix_file.is_open()) {
	
		//Continously goes through line by line in matrix file until there are no more lines to read
		while (getline(matrix_file,line)) {
			//If the line is not empty and the back of it contains a newline character, it removes it
			if(!line.empty() && line.back() == '\n') {
				//Removes the newline character at the end of the line
				line.pop_back();
			}
			//If line number is 1, the matrix size number is there
			if(line_number ==1) {
				//Declares and intializes a stringstream object for parsing of the line
				std::stringstream ss(line);
				//Extracts the matrix size form the stirng stream object for storing in size of matrix
				ss >> size_of_matrix;
				cout<<"Size of Matrix: "<<size_of_matrix<<"\n";
				ss >> type_flag;
				//Declares and initializes rows to size of matrix
				
				int rows = size_of_matrix;
				//Declares and initializes columns to size of matrix
				int columns = size_of_matrix;
    			matrix1 = Matrix<T>(rows,columns);
    			//Declares and initializes matrix2 to Matrix object with rows and columns passed in
    			matrix2 = Matrix<T>(rows,columns);
				
				
			}
			//If the line number is not 1, then the rest of the lines are Matrix numbers to be stored
			else {
				//Declares and intializes a stringstream object for parsing of the line
				std::stringstream ss(line);
				//Declares string cell element
				string cell_element;
				//Checks if line is not empty with the line size
				if(line.size()-1) {
					//If current row is within bound of size of matrix
					if(current_row < size_of_matrix) {
						//For in loop to iterate through each column 
						for(int column = 0; column<size_of_matrix; column++) {
							//Gets the cell element until hitting a empty space and stores it in cell element
							std::getline(ss,cell_element,' ');
							T value = stringToType<T>(cell_element);
							matrix1.store_cell_value(current_row,column,value);
							
						}
						//If the current row is equal to size of matrix, the next matrix is to be stored with the other elements
						if(current_row == size_of_matrix) {
							//Initialzies current matrix 2 row to 0
							current_matrix_2_row = 0;
						}
					}
					//Current row is not less than size of matrix, means the nex matrix needs to be stored with elements
					else {
						//For in loop to iterate through each column
						for(int column = 0; column<size_of_matrix; column++) {
							////Gets the cell element until hitting a empty space and stores it in cell element
							std::getline(ss,cell_element,' ');
							T value = stringToType<T>(cell_element);
							matrix2.store_cell_value(current_matrix_2_row ,column,value);
							
						}
						//current matrix 2 row is incremented
						current_matrix_2_row ++;
					}
				}
				//Current row is incremented
				current_row++;
			}
			//Line number is incremented
			line_number++;
		}
	}
	//Matrix file is closed
	matrix_file.close();
	//Returns the pair with amtrix 1 and 2 in it
	return {matrix1,matrix2};
}

class IntegerMatrix:public Matrix<int>{
    public:
        IntegerMatrix(int rows, int columns):Matrix<int>(rows,columns){}
        
        Matrix<int> swap_rows(int row_num_1,int row_num_2) override {
            return Matrix<int>::swap_rows(row_num_1,row_num_2);
        }
        Matrix<int> swap_columns(int column_num_1,int column_num_2) override {
            return Matrix<int>::swap_columns(column_num_1,column_num_2);
        }
};
class DoubleMatrix:public Matrix<double>{
    public:
        DoubleMatrix(int rows, int columns):Matrix<double>(rows,columns){}
        
        Matrix<double> swap_rows(int row_num_1,int row_num_2) override {
            return Matrix<double>::swap_rows(row_num_1,row_num_2);
        }
        Matrix<double> swap_columns(int column_num_1,int column_num_2) override {
            return Matrix<double>::swap_columns(column_num_1,column_num_2);
        }
};
//Function that return a matrix with its rows swapped, takes in a matrix object, integer row num 1 and 2 as input
template <typename T>
Matrix<T>Matrix<T>::swap_rows(int row_num_1,int row_num_2) {
	//Matrix result matrix object is set to the matrix 1 object
	row_num_1--;
	row_num_2--;
	Matrix<T> result_matrix = *this;


	//If row num 1 is greater than matrix 1 number of rows, it is out of bounds
	if(row_num_1> this->get_number_of_rows()) {
		//Returns result matrix object
		return result_matrix;
	}
	//If row num 2 is greater than matrix 1 number of rows, it is out of bounds
	else if(row_num_2> this->get_number_of_rows()) {
		//Returns result matrix object
		return result_matrix;
	}
	//If row num 1 is lesser than 0, it is out of bounds
	else if(row_num_1 < 0) {
		//Returns result matrix object
		return result_matrix;
	}
	//If row num 2 is lesser than 0, it is out of bounds
	else if(row_num_2 < 0) {
		//Returns result matrix object
		return result_matrix;
	}
	//If rows are in bounds, swapping can be done for the rows
	else {
		//For in loop to iterate through each column
		for(int column = 0; column< this->get_number_of_columns(); column++) {
			//Declare and initialize value to the matrix1 at grid lcoation row num2 by column
			int value = this->get_cell_value(row_num_2,column);
			//Result matrix stores the value at the row num1 location at column with the value to swap it
			result_matrix.store_cell_value(row_num_1,column,value);
		}
		//For in loop to iterate through each column
		for(int column = 0; column< this->get_number_of_columns(); column++) {
			//Declare and initialize value to the matrix1 at grid lcoation row num1 by column
			int value = this->get_cell_value(row_num_1,column);
			//Result matrix stores the value at the row num2 location at column with the value to swap it
			result_matrix.store_cell_value(row_num_2,column,value);
		}
		//Returns the result matrix object with rows swapped
		return result_matrix;
	}
}



//ChatGpt helped me with finnding how to swap columns 

//Function that return a matrix with its rows swapped, takes in a matrix object, integer column num 1 and 2 as input
template <typename T>
Matrix<T> Matrix<T>::swap_columns(int column_num_1,int column_num_2) {
	//Matrix result matrix object is set to the matrix 1 object
	column_num_1--;
	column_num_2--;
	Matrix<T> result_matrix = *this;

	//If column num 1 is greater than matrix 1 number of columns, its out of bounds
	if(column_num_1> this->get_number_of_columns()) {
		//Returns result matrix
		return result_matrix;
	}
	//If column num 2 is greater than matrix 1 number of columns, its out of bounds
	else if(column_num_2> this->get_number_of_columns()) {
		//Returns result matrix
		return result_matrix;
	}
	//If column num 1 lessser than 0, it is out of bounds
	else if(column_num_1 < 0) {
		//Returns result matrix
		return result_matrix;
	}
	//If column num 2 lessser than 0, it is out of bounds
	else if(column_num_2 < 0) {
		//Returns result matrix
		return result_matrix;
	}
	//If column number are in bound, swapping of columns can happen
	else {
		//For in loop to iterate through each row
		for(int row = 0; row< this->get_number_of_rows(); row++) {
			//Declare and initialize value to the matrix1 at grid lcoation row by column num2
			T value = this->get_cell_value(row,column_num_2);
			//Result matrix stores the value at the row  location at column num 1 with the value to swap it
			result_matrix.store_cell_value(row,column_num_1,value);
		}
		//For in loop to iterate through each row
		for(int row = 0; row< this->get_number_of_rows(); row++) {
			//Declare and initialize value to the matrix1 at grid lcoation row  by column num 1
			T value = this->get_cell_value(row,column_num_1);
			//Result matrix stores the value at the row  location at column num 2 with the value to swap it
			result_matrix.store_cell_value(row,column_num_2,value);
		}
		//Returns the result matrix object with columns swapped
		return result_matrix;
	}
}

//Function that returns a updated matrix object with integer row,column, and value passed in as argument to update matrix at row by column location with new value
template <typename T>
Matrix<T>Matrix<T>::update_matrix(Matrix<T>& matrix,int row,int column, T value) {
    Matrix<T> result_matrix = matrix;
	//Matrix obejct executes the store value with row,column,value input passed in to store the value at that row by column location
	result_matrix.store_cell_value(row,column,value);
	//Returns matrix object
	return result_matrix;
}





template <typename T> 
void choice_selection(string matrix_text_file) {
    cout << "In and out with type: " << typeid(T).name() << "\n";
	pair<Matrix<T>,Matrix<T>> matrices = create_matrices<T>(matrix_text_file);
	Matrix<T> matrix_1= matrices.first;
	Matrix<T> matrix_2= matrices.second;
	
	matrix_1.print_grid();
	matrix_2.print_grid();
	cout<<"\n";
	matrix_1 = matrix_1.add_matrices(matrix_2);
	
	
	
	
	cout<<"Result"<<"\n\n";
	matrix_1.print_grid();
	
}







int main(){
    cout<<"Hello! Welcome to the Matrix Function and Operations Program!"<<"\n";
    string matrix_text_file;
    cout<<"Enter Matrix _text file";
    cin>>matrix_text_file;
    
    ifstream file(matrix_text_file);
    string first_line;
    string matrix_size;
    string type;
    
    string line;
    int line_count = 0;
    
    while(getline(file,line)){
        line_count++;
    }
    file.clear();
    file.seekg(0);
    
    if(getline(file,first_line)){
        std::stringstream ss(first_line);
        ss>>matrix_size;
        int size_of_matrix = stoi(matrix_size);
        ss>>type;
        cout<<type<<"\n";
    }
    file.close();
    cout<<line_count<<"\n";
    
    if(type == "0"){
        choice_selection<int>(matrix_text_file);
    }
    else if(type == "1"){
        choice_selection<double>(matrix_text_file);
    }
    else{
        cout<<"Invald"<<"\n";
    }
    
    
    cout<<"\n";
    
    cout<<"Program Has Ended! Goodbye!"<<"\n";
    return 0;
}
