
//Includes the iostream library file to include standard input and ouput for cin and cout
#include <iostream>
//Includes the C++ fstream libary for file input and output, open and close functionality
#include <fstream>
//Includes the C++ string library for string manipulation and implmentation
#include <string>
//Includes the C++ sstream library for file string parsing functionality
#include <sstream>
//Includes the C++ vector library for array manipulation and implementation
#include <vector>
//Using standard namespace to avoid using std:: prefix
using namespace std;


template <typename T> class Matrix{
    private:
        int number_of_rows;
        int number_of_columns;
        vector<vector<T>> grid;
    public:
		Matrix(int rows, int columns);
		
		int get_number_of_rows();
		int get_number_of_columns();
		T get_cell_value(int row, int column);


		void store_cell_value(int row, int column, T value);
		
		void print_grid();
		void add_matrices(Matrix<T>&other);
		void multiply_matrices(Matrix<T>&other);
		void sum_diagonal();
		Matrix<T> swap_rows(int row1, int row2);
		Matrix<T> swap_columns(int column1, int column2);
		Matrix<T> updated_matrix_cell(int row, int column, T value);

		Matrix<T> operator+(Matrix<T>&other);
		Matrix<T> operator*(Matrix<T>&other);
};



template <typename T> Matrix<T>::Matrix(int rows, int columns){
    number_of_rows = rows;
    number_of_columns = columns;
    grid.resize(rows, vector<T>(columns));
}

template <typename T> int Matrix<T>::get_number_of_rows(){
    return number_of_rows;
}

template <typename T> int Matrix<T>::get_number_of_columns(){
    return number_of_columns;
}

template <typename T> T Matrix<T>::get_cell_value(int row, int column){
    return grid[row][column];
}

template <typename T> void Matrix<T>::store_cell_value(int row, int column, T value){
    grid[row][column] = value;
}

template <typename T> void Matrix<T>::print_grid(){
    cout<< "Column ";
    //For in loop to iterate through eaach column and print a number to indicate position of cell
    for(int column = 1; column < number_of_columns+1; column++){
        ////Prints to terminal ouput a | to indicate a barrier spacing
        cout<< column << "|";
    }
    //Prints newline spacing
    cout<<"\n";
    //For in loop to iterate throguh each row
    for(int row= 0; row<number_of_rows; row++) {
        //Pritns to terminal ouput the Row and number wiht a | to indicate barreier spacing and cell location
        cout<< "Row "<<row << "| ";
        //For in loop to iterate through each columns
        for(int column = 0; column < number_of_columns; column++) {
            //Prints to terminal ouput the value at grid of row by column location witha  space
            cout<<grid[row][column]<< " ";
        }
        //Prints newline spacing
        cout<<"\n";
    }
}

template<typename T>void Matrix<T>::sum_diagonal(){
	//Declare and initializes column number to 0
	int column_number = 0;
	//Declares and initializes matrix 1 result main sum to 0
	int matrix_result_main_sum = 0;
	//Declares and initializes matrix 1 result secondary sum to 0
	int matrix_result_secondary_sum = 0;

	//For in loop to iterate through each row n matrix 1 number of rows
	for(int row = 0; row < get_number_of_rows(); row++) {
		//Matrix 1 result main sum is incremeneted by the value at matrix 1 gird at location row  by column number
		matrix_result_main_sum+= get_cell_value(row,column_number);
		//Column number is incremented
		column_number++;
	}

	//Column number is set to matrix 1 number of columns minus by 1
	column_number = get_number_of_columns()-1;
	//For in loop to iterate through each row n matrix 1 number of rows
	for(int row = 0; row < get_number_of_rows(); row++) {
		//Matrix 1 result main sum is incremeneted by the value at matrix 1 gird at location row  by column number
		matrix_result_secondary_sum+= get_cell_value(row,column_number);
		//Column number is decremented
		column_number--;
	}
	//Prints ouput to terminal the Matrix main diagonal sum 
	cout<<"Matrix Main Diagonal Sum " << matrix_result_main_sum << "\n";
	//Prints ouput to terminal the Matrix secondary diagonal sum 
	cout<<"Matrix Secondary Diagonal Sum"<< matrix_result_secondary_sum << "\n";
}

template <typename T>
pair<Matrix<T>,Matrix<T>>create_matrices(string& matrix_text_file){
    //Declares string line to hol line of file
	string line;
	//Declares and initializes integer line number to 1 to keep track of the number of line there are
	int line_number = 1;
	//Declares and initializes integer current row to -1 to keep track of the placment of rows to matrices
	int current_row=-1;
	//Declares and initializes integer current matrix 2 row to 0, to keep track of the placmeent of matrix 2 rows
	int current_matrix_2_row = 0;
	//Declares integer size of matrix to hold matrix size
	int size_of_matrix;
	//Matrix object matrix 1 is declared and initialized with with a 0,0 pair passed in to indicate the vector grid is 0,0 in size
	Matrix<T> matrix1(0,0);
	//Matrix object matrix 2 is declared and initialized with with a 0,0 pair passed in to indicate the vector grid is 0,0 in size
	Matrix<T> matrix2(0,0);

	//Opens the matrix text file in the matrix file ifstream object for reading and extracting information
	ifstream matrix_file(matrix_text_file);
	//The matrix file is opened
	if (matrix_file.is_open()) {
	
		//Continously goes through line by line in matrix file until there are no more lines to read
		while (getline(matrix_file,line)) {
			//If the line is not empty and the back of it contains a newline character, it removes it
			if(!line.empty() && line.back() == '\n') {
				//Removes the newline character at the end of the line
				line.pop_back();
			}
			//If line number is 1, the matrix size number is there
			if(line_number ==1) {
				//Declares and intializes a stringstream object for parsing of the line
				std::stringstream ss(line);
				//Extracts the matrix size form the stirng stream object for storing in size of matrix
				ss >> size_of_matrix;
				//Declares and initializes rows to size of matrix
				int rows = size_of_matrix;
				//Declares and initializes columns to size of matrix
				int columns = size_of_matrix;
				//Declares and initializes matrix1 to Matrix object with rows and columns passed in
				matrix1 = Matrix<T>(rows,columns);
				//Declares and initializes matrix2 to Matrix object with rows and columns passed in
				matrix2 = Matrix<T>(rows,columns);
			}
			//If the line number is not 1, then the rest of the lines are Matrix numbers to be stored
			else {
				//Declares and intializes a stringstream object for parsing of the line
				std::stringstream ss(line);
				//Declares string cell element
				string cell_element;
				//Checks if line is not empty with the line size
				if(line.size()-1) {
					//If current row is within bound of size of matrix
					if(current_row < size_of_matrix) {
						//For in loop to iterate through each column 
						for(int column = 0; column<size_of_matrix; column++) {
							//Gets the cell element until hitting a empty space and stores it in cell element
							std::getline(ss,cell_element,' ');
							//Declares and initializes cell element convert to integer
							int value = stoi(cell_element);
							//matrix 1 object executes the store value function with current row and colum with value passed in to store that value in the row by colum ni grid of matrix1
							matrix1.store_cell_value(current_row,column,value);
						}
						//If the current row is equal to size of matrix, the next matrix is to be stored with the other elements
						if(current_row == size_of_matrix) {
							//Initialzies current matrix 2 row to 0
							current_matrix_2_row = 0;
						}
					}
					//Current row is not less than size of matrix, means the nex matrix needs to be stored with elements
					else {
						//For in loop to iterate through each column
						for(int column = 0; column<size_of_matrix; column++) {
							////Gets the cell element until hitting a empty space and stores it in cell element
							std::getline(ss,cell_element,' ');
							//Declares and initializes cell element convert to integer
							int value = stoi(cell_element);
							//matrix 2 object executes the store value function with current matrix 2 row and colum with value passed in to store that value in the row by colum ni grid of matrix2
							matrix2.store_cell_value(current_matrix_2_row ,column,value);
						}
						//current matrix 2 row is incremented
						current_matrix_2_row ++;
					}
				}
				//Current row is incremented
				current_row++;
			}
			//Line number is incremented
			line_number++;
		}
	}
	//Matrix file is closed
	matrix_file.close();
	//Returns the pair with amtrix 1 and 2 in it
	return {matrix1,matrix2};
}

//Function that return a matrix with its rows swapped, takes in a matrix object, integer row num 1 and 2 as input
template <typename T>Matrix<T> swap_rows(Matrix<T> matrix_1,int row_num_1,int row_num_2) {
	//Matrix result matrix object is set to the matrix 1 object
	Matrix<T> result_matrix = matrix_1;


	//If row num 1 is greater than matrix 1 number of rows, it is out of bounds
	if(row_num_1> matrix_1.get_number_of_rows()) {
		//Returns result matrix object
		return result_matrix;
	}
	//If row num 2 is greater than matrix 1 number of rows, it is out of bounds
	else if(row_num_2> matrix_1.get_number_of_rows()) {
		//Returns result matrix object
		return result_matrix;
	}
	//If row num 1 is lesser than 0, it is out of bounds
	else if(row_num_1 < 0) {
		//Returns result matrix object
		return result_matrix;
	}
	//If row num 2 is lesser than 0, it is out of bounds
	else if(row_num_2 < 0) {
		//Returns result matrix object
		return result_matrix;
	}
	//If rows are in bounds, swapping can be done for the rows
	else {
		//For in loop to iterate through each column
		for(int column = 0; column< matrix_1.get_number_of_columns(); column++) {
			//Declare and initialize value to the matrix1 at grid lcoation row num2 by column
			int value = matrix_1.get_grid_value(row_num_2,column);
			//Result matrix stores the value at the row num1 location at column with the value to swap it
			result_matrix.store_value(row_num_1,column,value);
		}
		//For in loop to iterate through each column
		for(int column = 0; column< matrix_1.get_number_of_columns(); column++) {
			//Declare and initialize value to the matrix1 at grid lcoation row num1 by column
			int value = matrix_1.get_grid_value(row_num_1,column);
			//Result matrix stores the value at the row num2 location at column with the value to swap it
			result_matrix.store_value(row_num_2,column,value);
		}
		//Returns the result matrix object with rows swapped
		return result_matrix;
	}
}



//ChatGpt helped me with finnding how to swap columns 

//Function that return a matrix with its rows swapped, takes in a matrix object, integer column num 1 and 2 as input
template <typename T>Matrix<T>  swap_columns(Matrix<T> matrix_1,int column_num_1,int column_num_2) {
	//Matrix result matrix object is set to the matrix 1 object
	Matrix<T> result_matrix = matrix_1;

	//If column num 1 is greater than matrix 1 number of columns, its out of bounds
	if(column_num_1> matrix_1.get_number_of_columns()) {
		//Returns result matrix
		return result_matrix;
	}
	//If column num 2 is greater than matrix 1 number of columns, its out of bounds
	else if(column_num_2> matrix_1.get_number_of_columns()) {
		//Returns result matrix
		return result_matrix;
	}
	//If column num 1 lessser than 0, it is out of bounds
	else if(column_num_1 < 0) {
		//Returns result matrix
		return result_matrix;
	}
	//If column num 2 lessser than 0, it is out of bounds
	else if(column_num_2 < 0) {
		//Returns result matrix
		return result_matrix;
	}
	//If column number are in bound, swapping of columns can happen
	else {
		//For in loop to iterate through each row
		for(int row = 0; row< matrix_1.get_number_of_rows(); row++) {
			//Declare and initialize value to the matrix1 at grid lcoation row by column num2
			int value = matrix_1.get_grid_value(row,column_num_2);
			//Result matrix stores the value at the row  location at column num 1 with the value to swap it
			result_matrix.store_value(row,column_num_1,value);
		}
		//For in loop to iterate through each row
		for(int row = 0; row< matrix_1.get_number_of_rows(); row++) {
			//Declare and initialize value to the matrix1 at grid lcoation row  by column num 1
			int value = matrix_1.get_grid_value(row,column_num_1);
			//Result matrix stores the value at the row  location at column num 2 with the value to swap it
			result_matrix.store_value(row,column_num_2,value);
		}
		//Returns the result matrix object with columns swapped
		return result_matrix;
	}
}

//Function that returns a updated matrix object with integer row,column, and value passed in as argument to update matrix at row by column location with new value
template <typename T>Matrix<T>  update_matrix(Matrix<T> matrix,int row,int column, int value) {
	//Matrix obejct executes the store value with row,column,value input passed in to store the value at that row by column location
	matrix.store_value(row,column,value);
	//Returns matrix object
	return matrix;
}



void choice_selection() {
    string matrix_text_file;
    cout<<"Enter Matrix Text File";
    cin >> matrix_text_file;
    
	pair<Matrix<int>,Matrix<int>> matrices = create_matrices<int>(matrix_text_file);
	Matrix<int> matrix_1= matrices.first;
	Matrix<int> matrix_2= matrices.second;
	matrix_1.print_grid();
	matrix_2.print_grid();
	
}


int main(){
    cout<<"Hello! Welcome to the Matrix Function and Operations Program!"<<"\n";
    cout<<"\n";
    choice_selection();
    cout<<"Program Has Ended! Goodbye!"<<"\n";
    return 0;
}